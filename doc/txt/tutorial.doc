/**

@page tutorial	Some steps to take to get started with paragui
@author Fred Ollinger

@section Introduction

Paragui is a library for creating graphical user
interfaces. It is licensed using the LGPL license, so you can develop
open software, free software, or even commercial non-free software
using GTK without having to spend anything for licenses or royalties.

Paragui is built upon SDL (http://www.libsdl.org/) which is
is a cross-platform multimedia library designed to provide low level access to
audio, keyboard, mouse, joystick, 3D hardware via OpenGL, and 2D video
framebuffer.
Thus Paragui is very cross-platform as well full featured. The power
of SDL is available in Paragui.

This tutorial is an attempt to document as much as possible of Paragui,
but it is by no means complete. This tutorial assumes a good
understanding of C++, and how to create C++ programs. It would be a great
benefit for the reader to have previous SDL programming experience, but
it shouldn't be necessary. If you are learning Paragui as your first
widget set, please comment on how you found this tutorial, and what
you had trouble with. There are also Python and Ruby, and
other language bindings available, and I believe C bindings in the works.
Check the bindings directory in the toplevel of the Paragui source code 
for details.

@section Getting Started

The first thing to do, of course, is download the Paragui source and
install it. You can always get the latest version from  
http://savannah.gnu.org/projects/paragui/ in
http://savannah.nongnu.org/files/?group=paragu. 
Paragui uses autoconf for configuration. Once the source code is unpacked, 
type ./configure --help to get a list of options.

To begin our introduction to Paragui, we'll start with the simplest
program possible. 

@code

#include "pgapplication.h"

int main() {
    // construct the application object
    PG_Application app;

    //app.EnableBackground(true);
    app.LoadTheme("default");

    // init 1024x768
    if(!app.InitScreen(800,600, 0, SDL_SWSURFACE)){
        printf("Resolution not supported\n");
        exit(-1);
    }

    // Enter main loop 
    app.Run();

    return EXIT_SUCCESS;
}

@endcode

You can compile the above program with gcc using:

g++ `paragui-config --cflags` -c hello.cpp
g++ hello.o -o hello `paragui-config --libs`

The first line will compile the hello.o file. It takes the output of paragui-config,
which is a program that is used to get the compilation flags. The next line
compiles the hello.o into an executable.

All programs will of course include "pgapplication.h" which 
contains the class that represents an application in ParaGUI. It handles the
main loop and screen attibutes.
 
An application must have a maximum of one PG_Application. If you try to create
more than one PG_Application the constructor will exit your application with an
console error message.

The first line, main() {, is boilerplate C++.

The next line, PG_Application app, creates the paragui application object.

The next line, app.LoadTheme("default"),
loads the theme. Themes are one of the greatest features of paragui as they
allow you to change the look and feel of an application without recoding C++.
Themes will be explained later. For now, its enough to know that you should
include this line as boilerplate code.

@code
    if(!app.InitScreen(800,600, 0, SDL_SWSURFACE)){
        printf("Resolution not supported\n");
        exit(-1);
    }
@endcode

This line pops up a window or it exits the application gracefully if the window
can not be popped up for some reason. 

Finally, app.Run(). 
This line is a bit confusing for people who are unused to
dealing with gui toolkits. Why do I need to run my app? Actually, the 
next line is a little misleading. The application can run without the next
line, but it won't be interactive unless you add a great deal of more code.

The app.Run() line inverts the usual way that an application runs. When one
writes a script style application, one instruction after the next is executing.

In the initial parts of this application, we have seen that this is true.
However, in a gui application, most of the app's time is spent waiting for user
input. 

Designers of toolkits were clever and made a shortcut so that instead of
writing code each time to handle all that input, it would be automatically
handled by the toolkit. Details of input handling will be explained in
subsequent chapters on callbacks.

*/
