#!/usr/bin/pike7.2

//
// A simple Pike script to generate the PG_Colors
// source files
//
string rgbfile = "rgb.txt";
string outfile = "pgcolors";
Stdio.File h;
Stdio.File c;

mapping(string:string|array(string)) colors = ([]);

void output(int r, int g, int b, string n)
{
    constant constfmt = "const SDL_Color %s = {%d, %d, %d};\n";
    constant codefmt = "\tcolors[\"%s\"] = %s;\n";
    
    string name = replace(String.trim_whites(n), ({" "}), ({"_"}));
    string name_lc = lower_case(name);
    
    h->write(sprintf(constfmt, name, r, g, b));
    if (name != name_lc)
        h->write(sprintf(constfmt, name_lc, r, g, b));

    // Output C++ code for this color
    c->write(sprintf(codefmt, name, name));
}

constant f_top =
"/*\n"
"    ParaGUI - crossplatform widgetset\n"
"    Copyright (C) 2000,2001,2002  Alexander Pipelka\n"
"\n"
"    This library is free software; you can redistribute it and/or\n"
"    modify it under the terms of the GNU Library General Public\n"
"    License as published by the Free Software Foundation; either\n"
"    version 2 of the License, or (at your option) any later version.\n"
"\n"
"    This library is distributed in the hope that it will be useful,\n"
"    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"    Library General Public License for more details.\n"
"\n"
"    You should have received a copy of the GNU Library General Public\n"
"    License along with this library; if not, write to the Free\n"
"    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"\n"
"    Alexander Pipelka\n"
"    pipelka@teleweb.at\n"
"\n"
"    Last Update:      $Author: braindead $\n"
"    Update Date:      $Date: 2002/04/15 13:22:10 $\n"
"    Source File:      $Source: /sources/paragui/paragui/bin/make_colors.pike,v $\n"
"    CVS/RCS Revision: $Revision: 1.1 $\n"
"    Status:           $State: Exp $\n\n"
"    Autogenerated from %s on %s"
"*/\n"
"\n"
"/** \file pgcolors.h"
"	Header file of the PG_Colors class.\n"
"	This header file also creates a bunch of useful color constants. To enable the\n"
"	creation of the color constants define "USE_COLOR_CONSTANTS" before including\n"
"	this header file.\n"
"*/\n\n";

constant class_def =
"/**\n"
"	@author Marek Habersack\n"
"	@short tool-class for descriptive colorvalues\n"
"*/\n"
"\n"
"class PG_Colors {\n"
" typedef STL_MAP<const char*, SDL_Color> colormap;\n"
" typedef STL_MAP<const char*, SDL_Color>::iterator cit;\n\n"
" public:\n"
"   PG_Colors() { if (!PG_Colors::initialized) {PG_Colors::InitColors(); PG_Colors::initialized = true;}}\n"
"   static bool FindColorByName(const char *name, SDL_Color &c) {\n"
"       cit col = PG_Colors::colors.find(name);\n"
"       if (col != PG_Colors::colors.end()) {\n"
"           c = colors[name];\n"
"           return true;\n"
"       }\n"
"       return false;\n"
"   }\n\n"
"   static const SDL_Color FindColorByName(const char *name) {\n"
"       SDL_Color c;\n"
"	if(FindColorByName(name, c)) {\n"
"		return c;\n"
"	}"
"       return colors["black"];\n"
"   }\n\n"
"   static void InitColors();\n\n"
"   const SDL_Color operator[](char *name) {\n"
"	return FindColorByName(static_cast<const char*>(name));\n"
"   }\n\n"
"   const SDL_Color operator[](const char *name) {\n"
"        return FindColorByName(name);\n"
"   }\n"
"   static void InitColors();\n\n"
" protected:\n"
"   static colormap colors;\n"
"   static bool     initialized;\n"
"};\n";

void generate_code()
{
    int           r, g, b;

    h = Stdio.File(outfile + ".h", "wct");
    c = Stdio.File(outfile + ".cpp", "wct");

    h->write(sprintf(f_top, rgbfile, ctime(time())));
    h->write("#ifndef PG_COLORS_H\n");
    h->write("#define PG_COLORS_H\n\n");
    h->write("#include <paragui.h>\n");
    h->write("#include MAP_INC\n\n");
    h->write("#ifdef USE_COLOR_CONSTANTS\n");

    c->write(sprintf(f_top, rgbfile, ctime(time())));
    c->write("#define USE_COLOR_CONSTANTS\n");
    c->write("#include \"" + outfile + ".h\"\n\n");
    c->write("PG_Colors::colormap PG_Colors::colors;\n");
    c->write("bool PG_Colors::initialized = false;\n\n");
    c->write("void PG_Colors::InitColors() {\n");
    
    foreach(indices(colors), string idx) {
        if (sscanf(idx, "%d%d%d", r, g, b) != 3)
            continue;

        if (arrayp(colors[idx])) {
            foreach(colors[idx], string name) {
                output(r, g, b, name);
            }
        } else
            output(r, g, b, colors[idx]);
    }
    h->write("#endif // !USE_COLOR_CONSTANTS\n\n");
    h->write(class_def);
    h->write("#endif // !PG_COLORS_H\n");
    c->write("}\n");

    c->close();
    h->close();
}

void process_line(string line)
{
    array(string) fields = (line / "\t") - ({""});

    if (sizeof(fields) != 2)
        return;
    
    if (colors[fields[0]]) {
        if (stringp(colors[fields[0]]))
            colors[fields[0]] = ({colors[fields[0]], fields[1]});
        else
            colors[fields[0]] += ({fields[1]});
    } else
        colors[fields[0]] = fields[1];
}

int main(int argc, array(string) argv)
{
    if (argc > 1)
        rgbfile = argv[1];
	
    Stdio.File f = Stdio.File(rgbfile, "r");
    
    if (!f) {
        write(sprintf("Cannot open file '%s' for reading\n", rgbfile));
        return 1;
    }
    
    array(string) lines = (f->read() / "\n") - ({""});
    f->close();

    foreach(lines, string line)
        process_line(line);

    generate_code();
    return 0;
}
